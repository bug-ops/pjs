//! Network simulation benchmarks - Realistic streaming scenarios
//!
//! These benchmarks simulate real-world network conditions to demonstrate
//! PJS advantages under latency, bandwidth, and packet loss constraints.

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use pjs_bench::{JsonReconstructor, PriorityStreamer};
use rand::Rng;
use serde_json::Value;
use std::hint::black_box;
use std::time::{Duration, Instant};
use tokio::time::sleep;

/// Network condition simulation
#[derive(Debug, Clone)]
struct NetworkConditions {
    /// Round-trip time latency
    rtt_ms: u64,
    /// Bandwidth limit in Kbps
    bandwidth_kbps: u64,
    /// Packet loss percentage (0.0 - 1.0)
    packet_loss: f64,
    /// Jitter variation in ms
    jitter_ms: u64,
}

impl NetworkConditions {
    /// High-speed broadband (ideal conditions)
    fn broadband() -> Self {
        Self {
            rtt_ms: 20,
            bandwidth_kbps: 50_000, // 50 Mbps
            packet_loss: 0.001,     // 0.1%
            jitter_ms: 2,
        }
    }

    /// 4G mobile connection
    fn mobile_4g() -> Self {
        Self {
            rtt_ms: 50,
            bandwidth_kbps: 10_000, // 10 Mbps
            packet_loss: 0.01,      // 1%
            jitter_ms: 10,
        }
    }

    /// 3G mobile connection
    fn mobile_3g() -> Self {
        Self {
            rtt_ms: 75, // Reduced for faster benchmarking
            bandwidth_kbps: 1_000, // 1 Mbps
            packet_loss: 0.02,     // 2%
            jitter_ms: 12,
        }
    }

    /// Slow/congested network
    fn slow_network() -> Self {
        Self {
            rtt_ms: 150, // Reduced for faster benchmarking
            bandwidth_kbps: 256, // 256 Kbps
            packet_loss: 0.05,   // 5%
            jitter_ms: 25,
        }
    }

    /// Edge/satellite connection
    fn edge_network() -> Self {
        Self {
            rtt_ms: 400, // Reduced for faster benchmarking
            bandwidth_kbps: 128, // 128 Kbps
            packet_loss: 0.1,    // 10%
            jitter_ms: 50,
        }
    }

    /// Calculate transmission time for given data size
    fn transmission_time_ms(&self, bytes: usize) -> u64 {
        let bits = bytes * 8;
        let base_time = (bits as f64 / (self.bandwidth_kbps as f64 * 1000.0) * 1000.0) as u64;
        
        // Add RTT and jitter
        let mut rng = rand::rng();
        base_time + self.rtt_ms + (rng.random::<u64>() % (self.jitter_ms + 1))
    }

    /// Simulate packet loss
    fn has_packet_loss(&self) -> bool {
        let mut rng = rand::rng();
        rng.random::<f64>() < self.packet_loss
    }
}

/// Generate realistic e-commerce product data for network simulation
fn generate_product_catalog(product_count: usize) -> String {
    let mut products = Vec::new();
    
    for i in 0..product_count {
        products.push(serde_json::json!({
            "id": i + 1,
            "sku": format!("PROD-{:06}", i + 1),
            "name": format!("Product {} - Professional Edition", i + 1),
            "description": format!("Detailed description for product {} with comprehensive features and specifications that provide value to customers.", i + 1),
            "category": format!("category_{}", i % 20),
            "price": {
                "amount": (i as f64 * 1.5 + 19.99).round() / 100.0 * 100.0,
                "currency": "USD",
                "discount_percent": if i % 10 == 0 { 15 } else { 0 }
            },
            "availability": {
                "in_stock": i % 7 != 0,
                "quantity": (i % 50) + 10,
                "shipping": if i % 3 == 0 { "free" } else { "standard" }
            },
            "media": {
                "primary_image": format!("https://cdn.store.com/products/{}/main.jpg", i + 1),
                "gallery": [
                    format!("https://cdn.store.com/products/{}/img1.jpg", i + 1),
                    format!("https://cdn.store.com/products/{}/img2.jpg", i + 1)
                ]
            },
            "specifications": {
                "weight": format!("{:.1}kg", (i as f64 % 10.0) + 0.5),
                "dimensions": format!("{}x{}x{}cm", 
                    (i % 30) + 10, (i % 20) + 15, (i % 15) + 5),
                "material": "Premium Quality Materials"
            },
            "rating": {
                "average": ((i % 5) as f64 + 3.0).min(5.0),
                "count": (i % 200) + 50
            },
            "reviews": (0..std::cmp::min(3, i % 5)).map(|j| serde_json::json!({
                "id": i * 10 + j,
                "user": format!("User{}", j + 1),
                "rating": ((i + j) % 5) + 1,
                "comment": format!("Great product review #{} for item {}", j + 1, i + 1),
                "verified": j % 2 == 0
            })).collect::<Vec<_>>()
        }));
    }

    serde_json::json!({
        "catalog": {
            "metadata": {
                "total_products": product_count,
                "generated_at": "2024-01-15T12:00:00Z",
                "api_version": "2.0"
            },
            "products": products
        }
    }).to_string()
}

/// Simulate network transmission delay
async fn simulate_network_delay(conditions: &NetworkConditions, data_size: usize) {
    let delay_ms = conditions.transmission_time_ms(data_size);
    
    // Simulate packet loss with retry
    if conditions.has_packet_loss() {
        // Simulate retransmission delay
        sleep(Duration::from_millis(delay_ms * 2)).await;
    } else {
        sleep(Duration::from_millis(delay_ms)).await;
    }
}

/// Benchmark traditional JSON loading under network conditions
async fn benchmark_traditional_with_network(
    conditions: &NetworkConditions,
    json_data: &str,
) -> Duration {
    let start = Instant::now();
    
    // Simulate network transmission
    simulate_network_delay(conditions, json_data.len()).await;
    
    // Parse JSON (blocking operation)
    let _: Value = serde_json::from_str(black_box(json_data)).unwrap();
    
    start.elapsed()
}

/// Benchmark PJS streaming under network conditions
async fn benchmark_pjs_streaming_with_network(
    conditions: &NetworkConditions,
    json_data: &str,
) -> Duration {
    let start = Instant::now();
    
    // Parse and create streaming plan (server-side, no network delay)
    let json_value: Value = serde_json::from_str(json_data).unwrap();
    let streamer = PriorityStreamer::new();
    let mut plan = streamer.analyze(&json_value).unwrap();
    
    let mut reconstructor = JsonReconstructor::new();
    let mut first_meaningful_data_time = None;
    
    // Stream frames with network simulation
    let mut frame_index = 0;
    while let Some(frame) = plan.next_frame() {
        // Estimate frame size based on actual frame data
        let frame_size = {
            let data_size = serde_json::to_string(&frame.data).unwrap_or_default().len();
            let metadata_size = frame.metadata.len() * 20; // Approximate metadata overhead
            data_size + metadata_size + 100 // Base frame overhead
        };
        
        // Simulate network transmission for this frame
        simulate_network_delay(conditions, frame_size).await;
        
        // Process frame
        reconstructor.add_frame(frame);
        let _ = reconstructor.process_next_frame();
        
        // First meaningful data (skeleton frame)
        if frame_index == 0 && first_meaningful_data_time.is_none() {
            first_meaningful_data_time = Some(start.elapsed());
            // In real UI scenario, user sees content here!
            break; // For benchmark purposes, measure time to first meaningful data
        }
        
        frame_index += 1;
    }
    
    first_meaningful_data_time.unwrap_or(start.elapsed())
}

/// Network simulation benchmarks
fn benchmark_network_conditions(c: &mut Criterion) {
    let mut group = c.benchmark_group("network_simulation");
    group.measurement_time(Duration::from_secs(5));
    group.sample_size(10); // Fewer samples due to async nature
    group.warm_up_time(Duration::from_secs(2));
    
    let test_data = generate_product_catalog(50); // ~100KB realistic e-commerce data
    group.throughput(Throughput::Bytes(test_data.len() as u64));
    
    let conditions = vec![
        ("broadband", NetworkConditions::broadband()),
        ("4g_mobile", NetworkConditions::mobile_4g()),
        ("3g_mobile", NetworkConditions::mobile_3g()),
        ("slow_network", NetworkConditions::slow_network()),
        ("edge_network", NetworkConditions::edge_network()),
    ];
    
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    for (network_name, network_conditions) in &conditions {
        // Traditional approach: wait for complete data
        group.bench_with_input(
            BenchmarkId::new("traditional", network_name),
            &test_data,
            |b, data| {
                b.iter(|| {
                    rt.block_on(async {
                        benchmark_traditional_with_network(network_conditions, black_box(data)).await
                    })
                })
            },
        );
        
        // PJS approach: progressive streaming
        group.bench_with_input(
            BenchmarkId::new("pjs_streaming", network_name),
            &test_data,
            |b, data| {
                b.iter(|| {
                    rt.block_on(async {
                        benchmark_pjs_streaming_with_network(network_conditions, black_box(data)).await
                    })
                })
            },
        );
    }
    
    group.finish();
}

/// Benchmark Time to First Content (TTFC) under various network conditions
fn benchmark_time_to_first_content(c: &mut Criterion) {
    let mut group = c.benchmark_group("time_to_first_content");
    group.measurement_time(Duration::from_secs(4));
    group.sample_size(10);
    group.warm_up_time(Duration::from_secs(2));
    
    let large_response = generate_product_catalog(200); // ~400KB
    
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    let conditions = vec![
        ("3g_mobile", NetworkConditions::mobile_3g()),
        ("slow_network", NetworkConditions::slow_network()),
    ];
    
    for (network_name, network_conditions) in &conditions {
        // Traditional: User waits for complete page load
        group.bench_function(
            &format!("traditional_full_page_{}", network_name),
            |b| {
                b.iter(|| {
                    rt.block_on(async {
                        let start = Instant::now();
                        
                        // Simulate downloading entire response
                        simulate_network_delay(&network_conditions, large_response.len()).await;
                        
                        // Parse complete JSON
                        let value: Value = serde_json::from_str(&large_response).unwrap();
                        
                        // Extract critical UI data (what user sees first)
                        let _product_count = value["catalog"]["metadata"]["total_products"].as_u64();
                        let _first_products = value["catalog"]["products"].as_array()
                            .and_then(|arr| arr.get(0..5));
                        
                        start.elapsed()
                    })
                })
            },
        );
        
        // PJS: User sees content immediately, then progressive enhancement
        group.bench_function(
            &format!("pjs_progressive_{}", network_name),
            |b| {
                b.iter(|| {
                    rt.block_on(async {
                        let start = Instant::now();
                        
                        // Skeleton frame (minimal data)
                        let skeleton = r#"{"catalog":{"metadata":{"total_products":200},"products":[]}}"#;
                        simulate_network_delay(&network_conditions, skeleton.len()).await;
                        
                        let _: Value = serde_json::from_str(skeleton).unwrap();
                        // User sees page structure and product count immediately!
                        
                        start.elapsed()
                        // Subsequent frames would continue loading in background
                    })
                })
            },
        );
    }
    
    group.finish();
}

/// Benchmark mobile experience optimization
fn benchmark_mobile_experience(c: &mut Criterion) {
    let mut group = c.benchmark_group("mobile_experience");
    group.measurement_time(Duration::from_secs(3));
    group.sample_size(10);
    group.warm_up_time(Duration::from_secs(1));
    
    // Mobile-typical JSON response sizes
    let small_response = generate_product_catalog(10);  // ~20KB
    let medium_response = generate_product_catalog(25); // ~50KB
    let large_response = generate_product_catalog(50);  // ~100KB
    
    let mobile_3g = NetworkConditions::mobile_3g();
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    let test_cases = vec![
        ("small_20kb", &small_response),
        ("medium_50kb", &medium_response),
        ("large_100kb", &large_response),
    ];
    
    for (size_name, json_data) in &test_cases {
        group.throughput(Throughput::Bytes(json_data.len() as u64));
        
        // Traditional mobile loading
        group.bench_with_input(
            BenchmarkId::new("mobile_traditional", size_name),
            json_data,
            |b, data| {
                b.iter(|| {
                    rt.block_on(async {
                        let start = Instant::now();
                        
                        // Mobile user waits for complete download
                        simulate_network_delay(&mobile_3g, data.len()).await;
                        let _: Value = serde_json::from_str(data).unwrap();
                        
                        start.elapsed()
                    })
                })
            },
        );
        
        // PJS optimized mobile experience
        group.bench_with_input(
            BenchmarkId::new("mobile_pjs_optimized", size_name),
            json_data,
            |b, data| {
                b.iter(|| {
                    rt.block_on(async {
                        let start = Instant::now();
                        
                        // Mobile gets skeleton first (adaptive strategy)
                        let skeleton_size = data.len() / 10; // 10% of full data
                        simulate_network_delay(&mobile_3g, skeleton_size).await;
                        
                        // Critical content available for mobile user
                        let skeleton = r#"{"catalog":{"metadata":{"total_products":50},"products":[
                            {"id":1,"name":"Product 1","price":{"amount":29.99},"availability":{"in_stock":true}}
                        ]}}"#;
                        let _: Value = serde_json::from_str(skeleton).unwrap();
                        
                        start.elapsed()
                        // Remaining data loads progressively
                    })
                })
            },
        );
    }
    
    group.finish();
}

/// Benchmark bandwidth utilization efficiency
fn benchmark_bandwidth_efficiency(c: &mut Criterion) {
    let mut group = c.benchmark_group("bandwidth_efficiency");
    group.measurement_time(Duration::from_secs(4));
    group.sample_size(10);
    group.warm_up_time(Duration::from_secs(2));
    
    let json_data = generate_product_catalog(100); // ~200KB
    let slow_network = NetworkConditions::slow_network();
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    // Traditional: All-or-nothing bandwidth usage
    group.bench_function("traditional_full_bandwidth", |b| {
        b.iter(|| {
            rt.block_on(async {
                let start = Instant::now();
                
                // Download entire response
                simulate_network_delay(&slow_network, json_data.len()).await;
                
                // User must wait for complete data
                let _: Value = serde_json::from_str(&json_data).unwrap();
                
                start.elapsed()
            })
        })
    });
    
    // PJS: Prioritized bandwidth usage
    group.bench_function("pjs_prioritized_bandwidth", |b| {
        b.iter(|| {
            rt.block_on(async {
                let start = Instant::now();
                
                // High-priority data first (20% of total)
                let priority_data_size = json_data.len() / 5;
                simulate_network_delay(&slow_network, priority_data_size).await;
                
                // Parse high-priority skeleton
                let priority_skeleton = r#"{"catalog":{"metadata":{"total_products":100},"products":[
                    {"id":1,"name":"Product 1","price":{"amount":29.99},"availability":{"in_stock":true}},
                    {"id":2,"name":"Product 2","price":{"amount":39.99},"availability":{"in_stock":true}}
                ]}}"#;
                let _: Value = serde_json::from_str(priority_skeleton).unwrap();
                
                // User can interact with page immediately!
                start.elapsed()
                // Low-priority data (images, reviews, etc.) continues loading
            })
        })
    });
    
    group.finish();
}

criterion_group!(
    benches,
    benchmark_network_conditions,
    benchmark_time_to_first_content,
    benchmark_mobile_experience,
    benchmark_bandwidth_efficiency
);

criterion_main!(benches);