//! Priority JSON Streaming example
//!
//! This example demonstrates the core Priority JSON Streaming functionality:
//! - Analyzing JSON structure
//! - Generating skeleton + patches
//! - Priority-based frame delivery
//! - Incremental reconstruction

use pjson_rs::domain::entities::frame::PatchOperation;
use pjson_rs::{Priority, StreamFrame, StreamProcessor, StreamConfig};
use serde_json::json;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ðŸš€ Priority JSON Streaming Protocol Demo\n");

    // Create sample data representing a typical API response
    let sample_data = json!({
        "store": {
            "id": 12345,
            "name": "Book Haven",
            "status": "active",
            "location": "New York",
            "books": [
                {
                    "id": 1,
                    "title": "Clean Code",
                    "author": "Robert C. Martin",
                    "price": 32.99,
                    "category": "Programming",
                    "reviews": [
                        {"user": "Alice", "rating": 5, "text": "Excellent book for developers!"},
                        {"user": "Bob", "rating": 4, "text": "Very practical examples"},
                        {"user": "Charlie", "rating": 5, "text": "Must-read for any programmer"}
                    ]
                },
                {
                    "id": 2,
                    "title": "Design Patterns",
                    "author": "Gang of Four",
                    "price": 45.00,
                    "category": "Programming",
                    "reviews": [
                        {"user": "Diana", "rating": 5, "text": "Classic computer science"},
                        {"user": "Eve", "rating": 4, "text": "Good reference material"}
                    ]
                }
            ],
            "analytics": {
                "daily_visitors": 1250,
                "conversion_rate": 0.034,
                "popular_categories": ["Programming", "Science Fiction", "Business"],
                "sales_data": {
                    "last_30_days": [450, 523, 612, 578, 689, 734, 698, 756, 823, 891],
                    "revenue": 15678.90
                }
            },
            "staff": [
                {"name": "John Manager", "role": "manager", "email": "john@bookhaven.com"},
                {"name": "Jane Clerk", "role": "clerk", "email": "jane@bookhaven.com"}
            ]
        }
    });

    println!(
        "ðŸ“Š Original JSON size: {} bytes",
        serde_json::to_string(&sample_data)?.len()
    );

    // Create stream processor
    let config = StreamConfig::default();
    let processor = StreamProcessor::new(config);

    // Convert to bytes for processing
    let json_bytes = serde_json::to_vec(&sample_data)?;

    // Create frames manually for demonstration
    println!("ðŸ”„ Creating streaming frames manually for demonstration...");
    
    // Create skeleton frame (highest priority)
    let skeleton_frame = StreamFrame {
        data: json!({
            "dashboard": {
                "title": sample_data["dashboard"]["title"],
                "last_updated": sample_data["dashboard"]["last_updated"],
                "critical_alerts": sample_data["dashboard"]["critical_alerts"],
                "summary": null,
                "charts": [],
                "logs": []
            }
        }),
        priority: Priority::new(100).unwrap(),
        metadata: std::collections::HashMap::new(),
    };
    
    // Create summary frame (high priority)
    let summary_frame = StreamFrame {
        data: json!({
            "dashboard": {
                "summary": sample_data["dashboard"]["summary"]
            }
        }),
        priority: Priority::new(80).unwrap(),
        metadata: std::collections::HashMap::new(),
    };
    
    let mut frames = vec![skeleton_frame, summary_frame];

    println!(
        "ðŸ“‹ Streaming plan created with {} frames\n",
        plan.remaining_frames()
    );

    // Simulate streaming each frame
    let mut frame_count = 1;
    while let Some(frame) = plan.next_frame() {
        match frame {
            StreamFrame::Skeleton {
                data,
                priority,
                complete,
            } => {
                println!(
                    "ðŸ“¦ Frame {}: SKELETON (Priority: {:?})",
                    frame_count, priority
                );
                println!("   Complete: {}", complete);
                println!(
                    "   Structure: {}",
                    serde_json::to_string_pretty(&data)?
                        .lines()
                        .take(10)
                        .collect::<Vec<_>>()
                        .join("\n")
                );
                if serde_json::to_string(&data)?.lines().count() > 10 {
                    println!("   ... (truncated)");
                }
                println!();
            }
            StreamFrame::Patch { patches, priority } => {
                println!("ðŸ”§ Frame {}: PATCH (Priority: {:?})", frame_count, priority);
                println!("   {} patch operations:", patches.len());

                for (i, patch) in patches.iter().take(3).enumerate() {
                    let op_desc = match &patch.operation {
                        PatchOperation::Set { .. } => "SET".to_string(),
                        PatchOperation::Append { values } => {
                            format!("APPEND {} items", values.len())
                        }
                        PatchOperation::Replace { .. } => "REPLACE".to_string(),
                        PatchOperation::Remove => "REMOVE".to_string(),
                    };
                    println!(
                        "     {}. Path: {} -> Operation: {}",
                        i + 1,
                        patch.path.to_json_pointer(),
                        op_desc
                    );
                }

                if patches.len() > 3 {
                    println!("     ... and {} more patches", patches.len() - 3);
                }
                println!();
            }
            StreamFrame::Complete { checksum } => {
                println!("âœ… Frame {}: COMPLETE", frame_count);
                if let Some(checksum) = checksum {
                    println!("   Checksum: {}", checksum);
                }
                println!();
            }
        }

        frame_count += 1;

        // Simulate network delay between frames
        std::thread::sleep(std::time::Duration::from_millis(100));
    }

    println!("ðŸŽ‰ Streaming completed!");
    println!("\nðŸ“ˆ Performance Benefits:");
    println!("   â€¢ Critical data (ID, name, status) delivered in first frames");
    println!("   â€¢ User sees essential information immediately");
    println!("   â€¢ Large arrays (reviews, analytics) streamed progressively");
    println!("   â€¢ Total frames transmitted: {}", frame_count - 1);
    println!("   â€¢ Client can start rendering immediately after skeleton");

    // Demonstrate priority ordering
    println!("\nðŸŽ¯ Priority Analysis:");
    demonstrate_priority_calculation();

    Ok(())
}

fn demonstrate_priority_calculation() {
    let examples = vec![
        ("id", Priority::CRITICAL),
        ("name", Priority::HIGH),
        ("title", Priority::HIGH),
        ("description", Priority::MEDIUM),
        ("reviews", Priority::BACKGROUND),
        ("analytics", Priority::LOW),
    ];

    for (field, expected_priority) in examples {
        println!("   â€¢ '{}' field -> {:?} priority", field, expected_priority);
    }

    println!("\nðŸ’¡ This ensures users see the most important data first!");
}
